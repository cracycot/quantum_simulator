# Оптимизация 9-кубитного кода Шора

## Суть оптимизации

Вместо использования 8 физических анцилл одновременно, мы используем **1 физическую анциллу последовательно** для всех 8 измерений синдрома.

### До оптимизации:
- **Физические кубиты**: 9 (данные) + 8 (анциллы) = 17
- **State space**: 2^17 = 131,072 комплексных чисел
- **Память**: ~2 MB на state vector

### После оптимизации:
- **Физические кубиты**: 9 (данные) + 1 (анцилла) = 10  
- **State space**: 2^10 = 1,024 комплексных чисел
- **Память**: ~16 KB на state vector
- **Экономия**: **128× меньше памяти** (99.2% экономии)

---

## Алгоритм последовательных измерений

Для каждого синдрома S_k (k = 0..7):

```
1. Prepare:   ancilla ← |0⟩ (или |+⟩ для X-базиса)
2. Entangle:  применить гейты синдромной схемы между data и ancilla
3. Measure:   измерить ancilla → получить классический бит s_k
4. Reset:     ancilla ← |0⟩ (готова к переиспользованию)
```

### Почему это работает?

После измерения анциллы совместное состояние коллапсирует:

```
|ψ⟩_{data,ancilla} → |ψ_{s_k}⟩_{data} ⊗ |s_k⟩_{ancilla}
```

Анцилла **факторизуется** от данных:
- Результат измерения s_k сохранён классически
- Анциллу можно сбросить и переиспользовать
- Состояние данных не зависит от старой анциллы

---

## Стабилизаторы кода Шора

### Bit-Flip (X-ошибки) — 6 ZZ-стабилизаторов

Измеряют парные кубиты внутри каждого блока:

**Блок 1** (q₀, q₁, q₂):
- S₀ = Z₀Z₁ (через анциллу a₀)
- S₁ = Z₁Z₂ (через анциллу a₁)

**Блок 2** (q₃, q₄, q₅):
- S₂ = Z₃Z₄ (через анциллу a₂)
- S₃ = Z₄Z₅ (через анциллу a₃)

**Блок 3** (q₆, q₇, q₈):
- S₄ = Z₆Z₇ (через анциллу a₄)
- S₅ = Z₇Z₈ (через анциллу a₅)

**Синдромная схема для ZZ (Z-базис)**:
```
ancilla |0⟩ ──●───●── Measure → s_k
              │   │
data_i   ─────┼───┼─────
              │   
data_j   ─────┼─────────
```
(CNOT от data к ancilla)

### Phase-Flip (Z-ошибки) — 2 X⊗⁶-стабилизатора

Сравнивают фазы между блоками:

- S₆ = X₀X₁X₂X₃X₄X₅ (блоки 1 и 2 в одной фазе) — через a₆
- S₇ = X₃X₄X₅X₆X₇X₈ (блоки 2 и 3 в одной фазе) — через a₇

**Синдромная схема для X⊗⁶ (X-базис)**:
```
ancilla |+⟩ ──┼──┼──┼──┼──┼──┼── H ── Measure → s_k
              │  │  │  │  │  │
data q_i  ────●──●──●──●──●──●──────
```
(CNOT от ancilla ко всем data кубитам)

---

## Физический смысл

### Как обнаруживаются X-ошибки (bit-flip)?

X-ошибка на кубите внутри блока:
```
|000⟩ + |111⟩  →  |100⟩ + |011⟩  (например, X₀)
```

ZZ-стабилизаторы видят, что кубиты в блоке **не согласованы** → синдром ≠ 0

### Как обнаруживаются Z-ошибки (phase-flip)?

Z-ошибка на кубите внутри блока **инвертирует фазу** блока:
```
(|000⟩ + |111⟩) → (|000⟩ − |111⟩)
```

Для ZZ-стабилизаторов (Z-базис) это незаметно (оба имеют одинаковый Z-eigenvalue).

Но X⊗⁶-стабилизаторы (X-базис) видят, что **фаза одного блока отличается от других** → синдром ≠ 0

---

## Интерпретация синдромов

### Bit-Flip Syndrome (s₀, s₁, s₂, s₃, s₄, s₅)

Для каждого блока — 2 бита синдрома:

| Синдром | Ошибка        | Коррекция |
|---------|---------------|-----------|
| (0, 0)  | Нет ошибки    | —         |
| (1, 0)  | X на 1-м кубите | X₀ (или X₃, X₆) |
| (1, 1)  | X на 2-м кубите | X₁ (или X₄, X₇) |
| (0, 1)  | X на 3-м кубите | X₂ (или X₅, X₈) |

### Phase-Flip Syndrome (s₆, s₇)

| Синдром | Ошибка         | Коррекция |
|---------|----------------|-----------|
| (0, 0)  | Нет Z-ошибки   | —         |
| (1, 0)  | Z в блоке 1    | Z₀        |
| (1, 1)  | Z в блоке 2    | Z₃        |
| (0, 1)  | Z в блоке 3    | Z₆        |

---

## Реализация

### 1. Создание системы с виртуализацией (`system.ts`)

```typescript
export function create9QubitShorSystem(): QuantumSystem {
  // Физическая система: 9 data + 1 ancilla = 10 qubits
  const system = new QuantumSystem(10);
  
  // Виртуальная карта: a0-a7 → физическая анцилла (index 9)
  system.virtualQubitMap = new Map([
    [9, 9],   // a0 → ancilla
    [10, 9],  // a1 → ancilla (reused)
    [11, 9],  // a2 → ancilla (reused)
    [12, 9],  // a3 → ancilla (reused)
    [13, 9],  // a4 → ancilla (reused)
    [14, 9],  // a5 → ancilla (reused)
    [15, 9],  // a6 → ancilla (reused)
    [16, 9],  // a7 → ancilla (reused)
  ]);
  
  return system;
}
```

### 2. Reset операция (`system.ts`)

```typescript
resetQubit(qubitIndex: number): void {
  const physicalIndex = this.mapToPhysical(qubitIndex);
  
  // Измерить и коллапсировать
  const result = this.state.measureQubit(physicalIndex);
  
  // Если |1⟩, применить X чтобы вернуть в |0⟩
  if (result === 1) {
    applyGateInternal(this.state, { name: 'X', qubits: [physicalIndex] });
  }
}
```

### 3. Измерение синдромов (`shor.ts`)

```typescript
export function measureBitFlipSyndrome(system: QuantumSystem) {
  const syndromes: number[] = [];
  
  // S0: Z0 Z1 через виртуальную a0 (физическая 9)
  system.applyGatesWithDescription([
    { name: 'CNOT', qubits: [0, 9], label: 'CNOT_{q0→a0}' },
    { name: 'CNOT', qubits: [1, 9], label: 'CNOT_{q1→a0}' }
  ], 'Измерение S₀', 'measurement');
  
  syndromes.push(system.measureQubit(9));
  system.resetQubit(9);  // ← Ключевой момент!
  
  // ... аналогично для S1-S5
  
  return syndromes;
}
```

### 4. UI индикация виртуализации (`QuantumCircuit.tsx`)

Для виртуальных анцилл:
- Пунктирная оранжевая линия на проводе
- Иконка "v" с подсказкой о маппинге
- Tooltip: "Virtual ancilla: maps to physical ancilla at index 9"

---

## Проверка работы

Запустите приложение и выберите код Шора (9 qubits):

1. **Проверьте state space**:
   - В консоли должно быть: `State dimension: 1024` (не 131072)

2. **Визуальная проверка**:
   - В схеме должна быть 1 физическая анцилла `a` (index 9)
   - При измерениях синдрома используются виртуальные a₀-a₇
   - На проводах виртуальных анцилл — оранжевые пунктиры с иконкой "v"

3. **Функциональная проверка**:
   - Применить X-ошибку → синдром должен корректно определить позицию
   - Применить Z-ошибку → фазовый синдром должен указать на блок
   - Коррекция должна восстановить fidelity > 99%

---

## Преимущества

✅ **Память**: 128× меньше (2^10 вместо 2^17)  
✅ **Скорость**: Быстрее симуляция (меньше размер state vector)  
✅ **Реализм**: Ближе к реальным квантовым устройствам (mid-circuit measurements)  
✅ **Масштабируемость**: Подход применим к более сложным кодам

## Ограничения

⚠️ **Последовательность**: Измерения синдромов последовательны (не параллельны)  
⚠️ **Mid-circuit measurement**: Требует поддержки измерений посередине схемы  
⚠️ **Reset операция**: Требует явного reset анциллы между измерениями

---

## Теоретическое обоснование

Это корректная оптимизация, потому что:

1. **Измерение коллапсирует анциллу**: После измерения анцилла не запутана с данными
2. **Классическое хранение**: Результаты s_k хранятся классически (не в квантовом состоянии)
3. **Независимость стабилизаторов**: Каждый стабилизатор измеряется независимо
4. **Стабилизаторный формализм**: Коммутирующие стабилизаторы можно измерять последовательно

Формально, для стабилизаторного кода:
```
[S_i, S_j] = 0  ⟹  можно измерять S_i и S_j последовательно одной анциллой
```

---

## Ссылки

- **Оригинальная статья**: Shor, P. W. (1995). "Scheme for reducing decoherence in quantum computer memory"
- **Стабилизаторные коды**: Gottesman, D. (1997). "Stabilizer Codes and Quantum Error Correction"
- **Эффективная симуляция**: Aaronson, S. & Gottesman, D. (2004). "Improved simulation of stabilizer circuits"

---

*Реализовано в рамках проекта QEC Simulator (ITMO University)*

